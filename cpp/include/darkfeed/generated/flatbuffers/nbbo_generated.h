// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NBBO_DARKFEED_SCHEMAS_FB_H_
#define FLATBUFFERS_GENERATED_NBBO_DARKFEED_SCHEMAS_FB_H_

#include "flatbuffers/flatbuffers.h"

#include "currency_generated.h"
#include "exchanges_generated.h"
#include "price_generated.h"
#include "quote_conditions_generated.h"
#include "symbol_generated.h"
#include "timestamps_generated.h"

namespace darkfeed {
namespace schemas {
namespace fb
{

struct NBBO;


struct NBBO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    enum {
        VT_SEQ_NUM = 4,
        VT_SYMBOL = 6,
        VT_BEST_BID_EXG = 8,
        VT_BEST_ASK_EXG = 10,
        VT_TS = 12,
        VT_BEST_BID = 14,
        VT_BEST_ASK = 16,
        VT_BEST_BID_SIZE = 18,
        VT_BEST_ASK_SIZE = 20,
        VT_BEST_BID_CONDITION = 22,
        VT_BEST_ASK_CONDITION = 24
    };

    uint64_t seq_num() const
    {
        return GetField<uint64_t>(VT_SEQ_NUM, 0);
    }

    const darkfeed::schemas::fb::Symbol *symbol() const
    {
        return GetPointer<const darkfeed::schemas::fb::Symbol *>(VT_SYMBOL);
    }

    darkfeed::schemas::fb::MIC best_bid_exg() const
    {
        return static_cast<darkfeed::schemas::fb::MIC>(GetField<uint8_t>(VT_BEST_BID_EXG, 0));
    }

    darkfeed::schemas::fb::MIC best_ask_exg() const
    {
        return static_cast<darkfeed::schemas::fb::MIC>(GetField<uint8_t>(VT_BEST_ASK_EXG, 0));
    }

    const darkfeed::schemas::fb::Timestamp *ts() const
    {
        return GetStruct<const darkfeed::schemas::fb::Timestamp *>(VT_TS);
    }

    const darkfeed::schemas::fb::Price *best_bid() const
    {
        return GetStruct<const darkfeed::schemas::fb::Price *>(VT_BEST_BID);
    }

    const darkfeed::schemas::fb::Price *best_ask() const
    {
        return GetStruct<const darkfeed::schemas::fb::Price *>(VT_BEST_ASK);
    }

    uint32_t best_bid_size() const
    {
        return GetField<uint32_t>(VT_BEST_BID_SIZE, 0);
    }

    uint32_t best_ask_size() const
    {
        return GetField<uint32_t>(VT_BEST_ASK_SIZE, 0);
    }

    darkfeed::schemas::fb::QuoteCondition best_bid_condition() const
    {
        return static_cast<darkfeed::schemas::fb::QuoteCondition>(GetField<uint8_t>(VT_BEST_BID_CONDITION, 0));
    }

    darkfeed::schemas::fb::QuoteCondition best_ask_condition() const
    {
        return static_cast<darkfeed::schemas::fb::QuoteCondition>(GetField<uint8_t>(VT_BEST_ASK_CONDITION, 0));
    }

    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) &&
               VerifyField<uint64_t>(verifier, VT_SEQ_NUM) &&
               VerifyField<flatbuffers::uoffset_t>(verifier, VT_SYMBOL) &&
               verifier.VerifyTable(symbol()) &&
               VerifyField<uint8_t>(verifier, VT_BEST_BID_EXG) &&
               VerifyField<uint8_t>(verifier, VT_BEST_ASK_EXG) &&
               VerifyField<darkfeed::schemas::fb::Timestamp>(verifier, VT_TS) &&
               VerifyField<darkfeed::schemas::fb::Price>(verifier, VT_BEST_BID) &&
               VerifyField<darkfeed::schemas::fb::Price>(verifier, VT_BEST_ASK) &&
               VerifyField<uint32_t>(verifier, VT_BEST_BID_SIZE) &&
               VerifyField<uint32_t>(verifier, VT_BEST_ASK_SIZE) &&
               VerifyField<uint8_t>(verifier, VT_BEST_BID_CONDITION) &&
               VerifyField<uint8_t>(verifier, VT_BEST_ASK_CONDITION) &&
               verifier.EndTable();
    }
};


struct NBBOBuilder {
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;

    void add_seq_num(uint64_t seq_num)
    {
        fbb_.AddElement<uint64_t>(NBBO::VT_SEQ_NUM, seq_num, 0);
    }

    void add_symbol(flatbuffers::Offset<darkfeed::schemas::fb::Symbol> symbol)
    {
        fbb_.AddOffset(NBBO::VT_SYMBOL, symbol);
    }

    void add_best_bid_exg(darkfeed::schemas::fb::MIC best_bid_exg)
    {
        fbb_.AddElement<uint8_t>(NBBO::VT_BEST_BID_EXG, static_cast<uint8_t>(best_bid_exg), 0);
    }

    void add_best_ask_exg(darkfeed::schemas::fb::MIC best_ask_exg)
    {
        fbb_.AddElement<uint8_t>(NBBO::VT_BEST_ASK_EXG, static_cast<uint8_t>(best_ask_exg), 0);
    }

    void add_ts(const darkfeed::schemas::fb::Timestamp *ts)
    {
        fbb_.AddStruct(NBBO::VT_TS, ts);
    }

    void add_best_bid(const darkfeed::schemas::fb::Price *best_bid)
    {
        fbb_.AddStruct(NBBO::VT_BEST_BID, best_bid);
    }

    void add_best_ask(const darkfeed::schemas::fb::Price *best_ask)
    {
        fbb_.AddStruct(NBBO::VT_BEST_ASK, best_ask);
    }

    void add_best_bid_size(uint32_t best_bid_size)
    {
        fbb_.AddElement<uint32_t>(NBBO::VT_BEST_BID_SIZE, best_bid_size, 0);
    }

    void add_best_ask_size(uint32_t best_ask_size)
    {
        fbb_.AddElement<uint32_t>(NBBO::VT_BEST_ASK_SIZE, best_ask_size, 0);
    }

    void add_best_bid_condition(darkfeed::schemas::fb::QuoteCondition best_bid_condition)
    {
        fbb_.AddElement<uint8_t>(NBBO::VT_BEST_BID_CONDITION, static_cast<uint8_t>(best_bid_condition), 0);
    }

    void add_best_ask_condition(darkfeed::schemas::fb::QuoteCondition best_ask_condition)
    {
        fbb_.AddElement<uint8_t>(NBBO::VT_BEST_ASK_CONDITION, static_cast<uint8_t>(best_ask_condition), 0);
    }

    NBBOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }

    NBBOBuilder &operator=(const NBBOBuilder &);

    flatbuffers::Offset<NBBO> Finish() {
        const auto end = fbb_.EndTable(start_, 11);
        auto o = flatbuffers::Offset<NBBO>(end);
        return o;
    }
};


inline flatbuffers::Offset<NBBO> CreateNBBO(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq_num = 0,
    flatbuffers::Offset<darkfeed::schemas::fb::Symbol> symbol = 0,
    darkfeed::schemas::fb::MIC best_bid_exg = darkfeed::schemas::fb::MIC::NONE,
    darkfeed::schemas::fb::MIC best_ask_exg = darkfeed::schemas::fb::MIC::NONE,
    const darkfeed::schemas::fb::Timestamp *ts = 0,
    const darkfeed::schemas::fb::Price *best_bid = 0,
    const darkfeed::schemas::fb::Price *best_ask = 0,
    uint32_t best_bid_size = 0,
    uint32_t best_ask_size = 0,
    darkfeed::schemas::fb::QuoteCondition best_bid_condition = darkfeed::schemas::fb::QuoteCondition::none,
    darkfeed::schemas::fb::QuoteCondition best_ask_condition = darkfeed::schemas::fb::QuoteCondition::none)
{
    NBBOBuilder builder_(_fbb);
    builder_.add_seq_num(seq_num);
    builder_.add_best_ask_size(best_ask_size);
    builder_.add_best_bid_size(best_bid_size);
    builder_.add_best_ask(best_ask);
    builder_.add_best_bid(best_bid);
    builder_.add_ts(ts);
    builder_.add_symbol(symbol);
    builder_.add_best_ask_condition(best_ask_condition);
    builder_.add_best_bid_condition(best_bid_condition);
    builder_.add_best_ask_exg(best_ask_exg);
    builder_.add_best_bid_exg(best_bid_exg);
    return builder_.Finish();
}

inline const darkfeed::schemas::fb::NBBO *GetNBBO(const void *buf)
{
    return flatbuffers::GetRoot<darkfeed::schemas::fb::NBBO>(buf);
}

inline bool VerifyNBBOBuffer(
    flatbuffers::Verifier &verifier)
{
    return verifier.VerifyBuffer<darkfeed::schemas::fb::NBBO>(nullptr);
}

inline void FinishNBBOBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<darkfeed::schemas::fb::NBBO> root)
{
    fbb.Finish(root);
}

}  // namespace fb
}  // namespace schemas
}  // namespace darkfeed

#endif  // FLATBUFFERS_GENERATED_NBBO_DARKFEED_SCHEMAS_FB_H_
