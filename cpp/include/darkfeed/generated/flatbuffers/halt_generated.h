// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HALT_DARKFEED_SCHEMAS_FB_H_
#define FLATBUFFERS_GENERATED_HALT_DARKFEED_SCHEMAS_FB_H_

#include "flatbuffers/flatbuffers.h"

#include "exchanges_generated.h"
#include "symbol_generated.h"
#include "timestamps_generated.h"

namespace darkfeed
{
namespace schemas
{
namespace fb
{

struct Halt;

enum class HaltType : uint8_t {
    ///< No Halt Type
        none = 0  ///< Unspecified news-related halt
    ,
    news = 1  ///< Denotes a regulatory trading halt when relevant news influencing the security is being disseminated. Trading is suspended until the primary market determines that an adequate publication or disclosure of information has occurred.
    ,
    news_disseminated = 2  ///< Denotes a non-regulatory halt condition where there is a significant imbalance of buy or sell orders.
    ,
    order_imbalance = 3  ///< Denotes a non-regulatory Trading Halt. The ability to trade a security by a Participant is temporarily inhibited due to a systems, equipment or communications facility problem or for other technical reasons.
    ,
    equipment_change = 4  ///< Unspecified halt requiring additional information before resuming trading.
    ,
    pending_additional_info = 5  ///< A financial status designation used to denote the ability to create new shares of this Exchange Traded Product (ETP) has been temporarily suspended by the ETP Issuer. ETPs that are closed for Creations typically are allowed to continue trading on the listing market once the ETP Issuer publishes the press release.
    ,
    suspended = 6  ///< Denotes a regulatory Trading halt mandated by the SEC for this security.
    ,
    sec = 7  ///< Unspecified halt.
    ,
    not_specified = 8  ///< Denotes a five-minute regulatory trading halt (pause) for an individual security that does not exit a Limit State within 15 seconds
    ,
    luld_pause = 9  ///< The level 1 market-wide circuit breaker (MWCB) has been triggered due to a 7%+ decline in S&P500 from last-session close. If before 3:25PM, all securities are halted for 15 min. If at or after 3:25PM trading continues unless there is a Level 3 MWCB.
    ,
    marketwide_halt_level1 = 10  ///< the level 2 market-wide circuit breaker (MWCB) has been triggered due to a 13% decline in S&P500 from last-session close. If before 3:25PM all securities are halted for 15 min. If after 3:25PM, trading continues unless there is a Level 3 MWCB.
    ,
    marketwide_halt_level2 = 11  ///< The level 3 market-wide circuit breaker (MWCB) has been triggered due to a 20% decline in S&P500 from last-session close. All equities are halted for the remainder of the day.
    ,
    marketwide_halt_level3 = 12  ///< Indicates the deactivation of a market-wide circuit breaker. This should only occur for level 1 and level 2 MWCB events.
    ,
    marketwide_halt_resume = 13  ///< Denotes a five-minute regulatory trading halt (pause) for an individual security that does not exit a Limit State within 15 seconds. The limit-state is calculated depending on the exchange. This is 5% for >$3.00 S&P 500, Russel 1000 securities, and certain ETPs, 10% for all other securities > $3.00. See: http://cdn.batstrading.com/resources/membership/BATS_US_Equities_Limit_Up_Limit_Down_FAQ.pdf
    ,
    luld_straddle = 14  ///< Halt due to unusual market activity. (Note: Find CTA Multicast equivalent)
    ,
    extraordinary_market_activity = 15  ///< Indicates an unspecified halt for an exchange traded product
    ,
    etf = 16  ///< Indicates a halt issued by an exchange for failure to meet listing or other unspecified regulatory requirements
    ,
    non_compliance = 17  ///< A regulatory halt issued for equities not meeting reporting requirements
    ,
    filings_not_current = 18  ///< Halt reason issued for exchange operations being impacted. For instance, a storm.
    ,
    operations = 19  ///< Pseudo-halt generated for IPO not occurring at market open
    ,
    ipo_pending = 20  ///< Halted due to an intra-day event like a split. Rare.
    ,
    corporate_action = 21  ///< Quotations have temporarily become unavailable for an unspecified reason.
    ,
    quote_unavailable = 22  ///< Generic halt condition for a single stock
    ,
    single_stock_pause = 23  ///< Generic resume condition for a single stock
    ,
    single_stock_pause_resume = 24,
    MIN = none,
    MAX = single_stock_pause_resume
};

inline const char **EnumNamesHaltType()
{
    static const char *names[] = {
        "none",
        "news",
        "news_disseminated",
        "order_imbalance",
        "equipment_change",
        "pending_additional_info",
        "suspended",
        "sec",
        "not_specified",
        "luld_pause",
        "marketwide_halt_level1",
        "marketwide_halt_level2",
        "marketwide_halt_level3",
        "marketwide_halt_resume",
        "luld_straddle",
        "extraordinary_market_activity",
        "etf",
        "non_compliance",
        "filings_not_current",
        "operations",
        "ipo_pending",
        "corporate_action",
        "quote_unavailable",
        "single_stock_pause",
        "single_stock_pause_resume",
        nullptr
    };
    return names;
}

inline const char *EnumNameHaltType(HaltType e)
{
    const size_t index = static_cast<int>(e);
    return EnumNamesHaltType()[index];
}

enum class HaltStatus : uint8_t {
    ///< Symbol is not currently halted
        none = 0  ///< Symbol was halted and is now resuming
    ,
    resume = 1  ///< Symbol is delayed at opening
    ,
    delay = 2  ///< Symbol is currently halted
    ,
    halted = 3  ///< Symbol is halted at open and will not trade during this session. Further quotations may not be issued.
    ,
    no_open_resume = 4,
    MIN = none,
    MAX = no_open_resume
};

inline const char **EnumNamesHaltStatus()
{
    static const char *names[] = {
        "none",
        "resume",
        "delay",
        "halted",
        "no_open_resume",
        nullptr
    };
    return names;
}

inline const char *EnumNameHaltStatus(HaltStatus e)
{
    const size_t index = static_cast<int>(e);
    return EnumNamesHaltStatus()[index];
}

struct Halt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    enum {
        VT_SEQ_NUM = 4,
        VT_SYMBOL = 6,
        VT_REPORTING_EXG = 8,
        VT_TS = 10,
        VT_HALT_TYPE = 12,
        VT_HALT_STATUS = 14
    };

    ///< Tickcaster monotonically increasing sequence number
    uint64_t seq_num() const
    {
        return GetField<uint64_t>(VT_SEQ_NUM, 0);
    }

    ///< Symbol corresponding to the halt
    const darkfeed::schemas::fb::Symbol *symbol() const
    {
        return GetPointer<const darkfeed::schemas::fb::Symbol *>(VT_SYMBOL);
    }

    ///< Exchange (if any) issuing the halt.
    darkfeed::schemas::fb::MIC reporting_exg() const
    {
        return static_cast<darkfeed::schemas::fb::MIC>(GetField<uint8_t>(VT_REPORTING_EXG, 0));
    }

    ///< Timestamp when the halt was issued
    const darkfeed::schemas::fb::Timestamp *ts() const
    {
        return GetStruct<const darkfeed::schemas::fb::Timestamp *>(VT_TS);
    }

    ///< Type of halt
    HaltType halt_type() const
    {
        return static_cast<HaltType>(GetField<uint8_t>(VT_HALT_TYPE, 0));
    }

    ///< Symbol's current status
    HaltStatus halt_status() const
    {
        return static_cast<HaltStatus>(GetField<uint8_t>(VT_HALT_STATUS, 0));
    }

    bool Verify(flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint64_t>(verifier, VT_SEQ_NUM) &&
               VerifyField<flatbuffers::uoffset_t>(verifier, VT_SYMBOL) &&
               verifier.VerifyTable(symbol()) &&
               VerifyField<uint8_t>(verifier, VT_REPORTING_EXG) &&
               VerifyField<darkfeed::schemas::fb::Timestamp>(verifier, VT_TS) &&
               VerifyField<uint8_t>(verifier, VT_HALT_TYPE) &&
               VerifyField<uint8_t>(verifier, VT_HALT_STATUS) &&
               verifier.EndTable();
    }
};

struct HaltBuilder {
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;

    void add_seq_num(uint64_t seq_num)
    {
        fbb_.AddElement<uint64_t>(Halt::VT_SEQ_NUM, seq_num, 0);
    }

    void add_symbol(flatbuffers::Offset<darkfeed::schemas::fb::Symbol> symbol)
    {
        fbb_.AddOffset(Halt::VT_SYMBOL, symbol);
    }

    void add_reporting_exg(darkfeed::schemas::fb::MIC reporting_exg)
    {
        fbb_.AddElement<uint8_t>(Halt::VT_REPORTING_EXG, static_cast<uint8_t>(reporting_exg), 0);
    }

    void add_ts(const darkfeed::schemas::fb::Timestamp *ts)
    {
        fbb_.AddStruct(Halt::VT_TS, ts);
    }

    void add_halt_type(HaltType halt_type)
    {
        fbb_.AddElement<uint8_t>(Halt::VT_HALT_TYPE, static_cast<uint8_t>(halt_type), 0);
    }

    void add_halt_status(HaltStatus halt_status)
    {
        fbb_.AddElement<uint8_t>(Halt::VT_HALT_STATUS, static_cast<uint8_t>(halt_status), 0);
    }

    HaltBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }

    HaltBuilder &operator=(const HaltBuilder &);

    flatbuffers::Offset<Halt> Finish()
    {
        const auto end = fbb_.EndTable(start_, 6);
        auto o = flatbuffers::Offset<Halt>(end);
        return o;
    }
};

inline flatbuffers::Offset<Halt> CreateHalt(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq_num = 0,
    flatbuffers::Offset<darkfeed::schemas::fb::Symbol> symbol = 0,
    darkfeed::schemas::fb::MIC reporting_exg = darkfeed::schemas::fb::MIC::NONE,
    const darkfeed::schemas::fb::Timestamp *ts = 0,
    HaltType halt_type = HaltType::none,
    HaltStatus halt_status = HaltStatus::none)
{
    HaltBuilder builder_(_fbb);
    builder_.add_seq_num(seq_num);
    builder_.add_ts(ts);
    builder_.add_symbol(symbol);
    builder_.add_halt_status(halt_status);
    builder_.add_halt_type(halt_type);
    builder_.add_reporting_exg(reporting_exg);
    return builder_.Finish();
}

inline const darkfeed::schemas::fb::Halt *GetHalt(const void *buf)
{
    return flatbuffers::GetRoot<darkfeed::schemas::fb::Halt>(buf);
}

inline bool VerifyHaltBuffer(
    flatbuffers::Verifier &verifier)
{
    return verifier.VerifyBuffer<darkfeed::schemas::fb::Halt>(nullptr);
}

inline void FinishHaltBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<darkfeed::schemas::fb::Halt> root)
{
    fbb.Finish(root);
}

}  // namespace fb
}  // namespace schemas
}  // namespace darkfeed

#endif  // FLATBUFFERS_GENERATED_HALT_DARKFEED_SCHEMAS_FB_H_
