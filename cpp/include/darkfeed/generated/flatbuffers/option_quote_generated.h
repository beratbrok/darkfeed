// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPTIONQUOTE_DARKFEED_SCHEMAS_FB_H_
#define FLATBUFFERS_GENERATED_OPTIONQUOTE_DARKFEED_SCHEMAS_FB_H_

#include "flatbuffers/flatbuffers.h"

#include "currency_generated.h"
#include "exchanges_generated.h"
#include "price_generated.h"
#include "quote_conditions_generated.h"
#include "symbol_generated.h"
#include "timestamps_generated.h"

namespace darkfeed
{
namespace schemas
{
namespace fb
{

struct OptionQuote;

enum class OptionType : uint8_t {
    put = 0,
    call = 1,
    MIN = put,
    MAX = call
};

inline const char **EnumNamesOptionType()
{
    static const char *names[] = {
        "put",
        "call",
        nullptr
    };
    return names;
}

inline const char *EnumNameOptionType(OptionType e)
{
    const size_t index = static_cast<int>(e);
    return EnumNamesOptionType()[index];
}

struct OptionQuote FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    enum {
        VT_SEQ_NUM = 4,
        VT_SYMBOL = 6,
        VT_OPTION_TYPE = 8,
        VT_REPORTING_EXG = 10,
        VT_TS = 12,
        VT_EXPIRATION = 14,
        VT_STRIKE = 16,
        VT_BID = 18,
        VT_ASK = 20,
        VT_BID_SIZE = 22,
        VT_ASK_SIZE = 24,
        VT_CONDITION = 26
    };

    uint64_t seq_num() const
    {
        return GetField<uint64_t>(VT_SEQ_NUM, 0);
    }

    const darkfeed::schemas::fb::Symbol *symbol() const
    {
        return GetPointer<const darkfeed::schemas::fb::Symbol *>(VT_SYMBOL);
    }

    OptionType option_type() const
    {
        return static_cast<OptionType>(GetField<uint8_t>(VT_OPTION_TYPE, 0));
    }

    darkfeed::schemas::fb::MIC reporting_exg() const
    {
        return static_cast<darkfeed::schemas::fb::MIC>(GetField<uint8_t>(VT_REPORTING_EXG, 0));
    }

    const darkfeed::schemas::fb::Timestamp *ts() const
    {
        return GetStruct<const darkfeed::schemas::fb::Timestamp *>(VT_TS);
    }

    const darkfeed::schemas::fb::Timestamp *expiration() const
    {
        return GetStruct<const darkfeed::schemas::fb::Timestamp *>(VT_EXPIRATION);
    }

    const darkfeed::schemas::fb::Price *strike() const
    {
        return GetStruct<const darkfeed::schemas::fb::Price *>(VT_STRIKE);
    }

    const darkfeed::schemas::fb::Price *bid() const
    {
        return GetStruct<const darkfeed::schemas::fb::Price *>(VT_BID);
    }

    const darkfeed::schemas::fb::Price *ask() const
    {
        return GetStruct<const darkfeed::schemas::fb::Price *>(VT_ASK);
    }

    uint32_t bid_size() const
    {
        return GetField<uint32_t>(VT_BID_SIZE, 0);
    }

    uint32_t ask_size() const
    {
        return GetField<uint32_t>(VT_ASK_SIZE, 0);
    }

    darkfeed::schemas::fb::QuoteCondition condition() const
    {
        return static_cast<darkfeed::schemas::fb::QuoteCondition>(GetField<uint8_t>(VT_CONDITION, 0));
    }

    bool Verify(flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint64_t>(verifier, VT_SEQ_NUM) &&
               VerifyField<flatbuffers::uoffset_t>(verifier, VT_SYMBOL) &&
               verifier.VerifyTable(symbol()) &&
               VerifyField<uint8_t>(verifier, VT_OPTION_TYPE) &&
               VerifyField<uint8_t>(verifier, VT_REPORTING_EXG) &&
               VerifyField<darkfeed::schemas::fb::Timestamp>(verifier, VT_TS) &&
               VerifyField<darkfeed::schemas::fb::Timestamp>(verifier, VT_EXPIRATION) &&
               VerifyField<darkfeed::schemas::fb::Price>(verifier, VT_STRIKE) &&
               VerifyField<darkfeed::schemas::fb::Price>(verifier, VT_BID) &&
               VerifyField<darkfeed::schemas::fb::Price>(verifier, VT_ASK) &&
               VerifyField<uint32_t>(verifier, VT_BID_SIZE) &&
               VerifyField<uint32_t>(verifier, VT_ASK_SIZE) &&
               VerifyField<uint8_t>(verifier, VT_CONDITION) &&
               verifier.EndTable();
    }
};

struct OptionQuoteBuilder {
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;

    void add_seq_num(uint64_t seq_num)
    {
        fbb_.AddElement<uint64_t>(OptionQuote::VT_SEQ_NUM, seq_num, 0);
    }

    void add_symbol(flatbuffers::Offset<darkfeed::schemas::fb::Symbol> symbol)
    {
        fbb_.AddOffset(OptionQuote::VT_SYMBOL, symbol);
    }

    void add_option_type(OptionType option_type)
    {
        fbb_.AddElement<uint8_t>(OptionQuote::VT_OPTION_TYPE, static_cast<uint8_t>(option_type), 0);
    }

    void add_reporting_exg(darkfeed::schemas::fb::MIC reporting_exg)
    {
        fbb_.AddElement<uint8_t>(OptionQuote::VT_REPORTING_EXG, static_cast<uint8_t>(reporting_exg), 0);
    }

    void add_ts(const darkfeed::schemas::fb::Timestamp *ts)
    {
        fbb_.AddStruct(OptionQuote::VT_TS, ts);
    }

    void add_expiration(const darkfeed::schemas::fb::Timestamp *expiration)
    {
        fbb_.AddStruct(OptionQuote::VT_EXPIRATION, expiration);
    }

    void add_strike(const darkfeed::schemas::fb::Price *strike)
    {
        fbb_.AddStruct(OptionQuote::VT_STRIKE, strike);
    }

    void add_bid(const darkfeed::schemas::fb::Price *bid)
    {
        fbb_.AddStruct(OptionQuote::VT_BID, bid);
    }

    void add_ask(const darkfeed::schemas::fb::Price *ask)
    {
        fbb_.AddStruct(OptionQuote::VT_ASK, ask);
    }

    void add_bid_size(uint32_t bid_size)
    {
        fbb_.AddElement<uint32_t>(OptionQuote::VT_BID_SIZE, bid_size, 0);
    }

    void add_ask_size(uint32_t ask_size)
    {
        fbb_.AddElement<uint32_t>(OptionQuote::VT_ASK_SIZE, ask_size, 0);
    }

    void add_condition(darkfeed::schemas::fb::QuoteCondition condition)
    {
        fbb_.AddElement<uint8_t>(OptionQuote::VT_CONDITION, static_cast<uint8_t>(condition), 0);
    }

    OptionQuoteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }

    OptionQuoteBuilder &operator=(const OptionQuoteBuilder &);

    flatbuffers::Offset<OptionQuote> Finish()
    {
        const auto end = fbb_.EndTable(start_, 12);
        auto o = flatbuffers::Offset<OptionQuote>(end);
        return o;
    }
};

inline flatbuffers::Offset<OptionQuote> CreateOptionQuote(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq_num = 0,
    flatbuffers::Offset<darkfeed::schemas::fb::Symbol> symbol = 0,
    OptionType option_type = OptionType::put,
    darkfeed::schemas::fb::MIC reporting_exg = darkfeed::schemas::fb::MIC::NONE,
    const darkfeed::schemas::fb::Timestamp *ts = 0,
    const darkfeed::schemas::fb::Timestamp *expiration = 0,
    const darkfeed::schemas::fb::Price *strike = 0,
    const darkfeed::schemas::fb::Price *bid = 0,
    const darkfeed::schemas::fb::Price *ask = 0,
    uint32_t bid_size = 0,
    uint32_t ask_size = 0,
    darkfeed::schemas::fb::QuoteCondition condition = darkfeed::schemas::fb::QuoteCondition::none)
{
    OptionQuoteBuilder builder_(_fbb);
    builder_.add_seq_num(seq_num);
    builder_.add_ask_size(ask_size);
    builder_.add_bid_size(bid_size);
    builder_.add_ask(ask);
    builder_.add_bid(bid);
    builder_.add_strike(strike);
    builder_.add_expiration(expiration);
    builder_.add_ts(ts);
    builder_.add_symbol(symbol);
    builder_.add_condition(condition);
    builder_.add_reporting_exg(reporting_exg);
    builder_.add_option_type(option_type);
    return builder_.Finish();
}

inline const darkfeed::schemas::fb::OptionQuote *GetOptionQuote(const void *buf)
{
    return flatbuffers::GetRoot<darkfeed::schemas::fb::OptionQuote>(buf);
}

inline bool VerifyOptionQuoteBuffer(
    flatbuffers::Verifier &verifier)
{
    return verifier.VerifyBuffer<darkfeed::schemas::fb::OptionQuote>(nullptr);
}

inline void FinishOptionQuoteBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<darkfeed::schemas::fb::OptionQuote> root)
{
    fbb.Finish(root);
}

}  // namespace fb
}  // namespace schemas
}  // namespace darkfeed

#endif  // FLATBUFFERS_GENERATED_OPTIONQUOTE_DARKFEED_SCHEMAS_FB_H_
