// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRADE_DARKFEED_SCHEMAS_FB_H_
#define FLATBUFFERS_GENERATED_TRADE_DARKFEED_SCHEMAS_FB_H_

#include "flatbuffers/flatbuffers.h"

#include "currency_generated.h"
#include "exchanges_generated.h"
#include "price_generated.h"
#include "symbol_generated.h"
#include "timestamps_generated.h"
#include "trade_conditions_generated.h"

namespace darkfeed {
namespace schemas {
namespace fb
{

struct Trade;


struct Trade FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    enum {
        VT_SEQ_NUM = 4,
        VT_SYMBOL = 6,
        VT_REPORTING_EXG = 8,
        VT_TS = 10,
        VT_PRICE = 12,
        VT_SIZE = 14,
        VT_VOL = 16,
        VT_T_VOL = 18,
        VT_CONDITION = 20
    };

    uint64_t seq_num() const
    {
        return GetField<uint64_t>(VT_SEQ_NUM, 0);
    }

    const darkfeed::schemas::fb::Symbol *symbol() const
    {
        return GetPointer<const darkfeed::schemas::fb::Symbol *>(VT_SYMBOL);
    }

    darkfeed::schemas::fb::MIC reporting_exg() const
    {
        return static_cast<darkfeed::schemas::fb::MIC>(GetField<uint8_t>(VT_REPORTING_EXG, 0));
    }

    const darkfeed::schemas::fb::Timestamp *ts() const
    {
        return GetStruct<const darkfeed::schemas::fb::Timestamp *>(VT_TS);
    }

    const darkfeed::schemas::fb::Price *price() const
    {
        return GetStruct<const darkfeed::schemas::fb::Price *>(VT_PRICE);
    }

    uint32_t size() const
    {
        return GetField<uint32_t>(VT_SIZE, 0);
    }

    uint32_t vol() const
    {
        return GetField<uint32_t>(VT_VOL, 0);
    }

    uint32_t t_vol() const
    {
        return GetField<uint32_t>(VT_T_VOL, 0);
    }

    darkfeed::schemas::fb::TradeCondition condition() const
    {
        return static_cast<darkfeed::schemas::fb::TradeCondition>(GetField<uint8_t>(VT_CONDITION, 0));
    }

    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) &&
               VerifyField<uint64_t>(verifier, VT_SEQ_NUM) &&
               VerifyField<flatbuffers::uoffset_t>(verifier, VT_SYMBOL) &&
               verifier.VerifyTable(symbol()) &&
               VerifyField<uint8_t>(verifier, VT_REPORTING_EXG) &&
               VerifyField<darkfeed::schemas::fb::Timestamp>(verifier, VT_TS) &&
               VerifyField<darkfeed::schemas::fb::Price>(verifier, VT_PRICE) &&
               VerifyField<uint32_t>(verifier, VT_SIZE) &&
               VerifyField<uint32_t>(verifier, VT_VOL) &&
               VerifyField<uint32_t>(verifier, VT_T_VOL) &&
               VerifyField<uint8_t>(verifier, VT_CONDITION) &&
               verifier.EndTable();
    }
};


struct TradeBuilder {
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;

    void add_seq_num(uint64_t seq_num)
    {
        fbb_.AddElement<uint64_t>(Trade::VT_SEQ_NUM, seq_num, 0);
    }

    void add_symbol(flatbuffers::Offset<darkfeed::schemas::fb::Symbol> symbol)
    {
        fbb_.AddOffset(Trade::VT_SYMBOL, symbol);
    }

    void add_reporting_exg(darkfeed::schemas::fb::MIC reporting_exg)
    {
        fbb_.AddElement<uint8_t>(Trade::VT_REPORTING_EXG, static_cast<uint8_t>(reporting_exg), 0);
    }

    void add_ts(const darkfeed::schemas::fb::Timestamp *ts)
    {
        fbb_.AddStruct(Trade::VT_TS, ts);
    }

    void add_price(const darkfeed::schemas::fb::Price *price)
    {
        fbb_.AddStruct(Trade::VT_PRICE, price);
    }

    void add_size(uint32_t size)
    {
        fbb_.AddElement<uint32_t>(Trade::VT_SIZE, size, 0);
    }

    void add_vol(uint32_t vol)
    {
        fbb_.AddElement<uint32_t>(Trade::VT_VOL, vol, 0);
    }

    void add_t_vol(uint32_t t_vol)
    {
        fbb_.AddElement<uint32_t>(Trade::VT_T_VOL, t_vol, 0);
    }

    void add_condition(darkfeed::schemas::fb::TradeCondition condition)
    {
        fbb_.AddElement<uint8_t>(Trade::VT_CONDITION, static_cast<uint8_t>(condition), 0);
    }

    TradeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }

    TradeBuilder &operator=(const TradeBuilder &);

    flatbuffers::Offset<Trade> Finish() {
        const auto end = fbb_.EndTable(start_, 9);
        auto o = flatbuffers::Offset<Trade>(end);
        return o;
    }
};


inline flatbuffers::Offset<Trade> CreateTrade(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seq_num = 0,
    flatbuffers::Offset<darkfeed::schemas::fb::Symbol> symbol = 0,
    darkfeed::schemas::fb::MIC reporting_exg = darkfeed::schemas::fb::MIC::NONE,
    const darkfeed::schemas::fb::Timestamp *ts = 0,
    const darkfeed::schemas::fb::Price *price = 0,
    uint32_t size = 0,
    uint32_t vol = 0,
    uint32_t t_vol = 0,
    darkfeed::schemas::fb::TradeCondition condition = darkfeed::schemas::fb::TradeCondition::none)
{
    TradeBuilder builder_(_fbb);
    builder_.add_seq_num(seq_num);
    builder_.add_t_vol(t_vol);
    builder_.add_vol(vol);
    builder_.add_size(size);
    builder_.add_price(price);
    builder_.add_ts(ts);
    builder_.add_symbol(symbol);
    builder_.add_condition(condition);
    builder_.add_reporting_exg(reporting_exg);
    return builder_.Finish();
}

inline const darkfeed::schemas::fb::Trade *GetTrade(const void *buf)
{
    return flatbuffers::GetRoot<darkfeed::schemas::fb::Trade>(buf);
}

inline bool VerifyTradeBuffer(
    flatbuffers::Verifier &verifier)
{
    return verifier.VerifyBuffer<darkfeed::schemas::fb::Trade>(nullptr);
}

inline void FinishTradeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<darkfeed::schemas::fb::Trade> root)
{
    fbb.Finish(root);
}

}  // namespace fb
}  // namespace schemas
}  // namespace darkfeed

#endif  // FLATBUFFERS_GENERATED_TRADE_DARKFEED_SCHEMAS_FB_H_
